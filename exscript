#!/usr/bin/env python
# Copyright (C) 2007 Samuel Abels, http://debain.org
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2, as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
import sys, os, re, getpass
sys.path.append('src')
from Exscript                import Queue, Account, Host
from Exscript.FooLib         import OptionParser
from Exscript.util           import template
from Exscript.util.interact  import get_login
from Exscript.util.file      import get_accounts_from_file, \
                                    get_hosts_from_file, \
                                    get_hosts_from_csv
from Exscript.util.decorator import autologin

True  = 1
False = 0

__version__ = '1.9.1'

def usage():
    print "Exscript", __version__
    print "Copyright (C) 2007-2009 by Samuel Abels <http://debain.org>."
    print "Syntax: exscript [options] exscript [hostname [hostname ...]]"
    print "      --account-pool FILE"
    print "                 Reads the user/password combination from the given file "
    print "                 instead of prompting on the command line. The file may"
    print "                 also contain more than one user/password combination, in"
    print "                 which case the accounts are used round robin."
    print "  -c, --connections NUM"
    print "                 Maximum number of concurrent connections."
    print "                 NUM is a number between 1 and 20, default is 1"
    print "      --csv-hosts FILE"
    print "                 Loads a list of hostnames and definitions from the given file."
    print "                 The first line of the file must have the column headers in the"
    print "                 following syntax:"
    print "                    hostname [variable] [variable] ..."
    print "                 where the fields are separated by tabs, \"hostname\" is the"
    print "                 keyword \"hostname\" and \"variable\" is a unique name under"
    print "                 which the column is accessed in the script."
    print "                 The following lines contain the hostname in the first column,"
    print "                 and the values of the variables in the following columns."
    print "  -d, --define PAIR"
    print "                 Defines a variable that is passed to the script."
    print "                 PAIR has the following syntax: <STRING>=<STRING>."
    print "      --default-domain STRING"
    print "                 The IP domain name that is used if a given hostname has no "
    print "                 domain appended."
    print "      --delete-logs"
    print "                 Delete logs of successful operations when done."
    print "  -e, --execute EXSCRIPT"
    print "                 Interpretes the given string as the script."
    print "      --hosts FILE"
    print "                 Loads a list of hostnames from the given file (one host per"
    print "                 line)."
    print "  -i, --non-interactive"
    print "                 Do not ask for a username or password."
    print "  -l, --logdir DIR"
    print "                 Logs any communication into the directory with the given name."
    print "                 Each filename consists of the hostname with \"_log\" appended."
    print "                 Errors are written to a separate file, where the filename"
    print "                 consists of the hostname with \".log.error\" appended."
    print "      --no-echo"
    print "                 Turns off the echo, such that the network activity is no longer"
    print "                 written to stdout."
    print "                 This is already the default behavior if the -c option was given"
    print "                 with a number greater than 1."
    print "  -n, --no-authentication"
    print "                 When given, the authentication procedure is skipped. Implies -i."
    print "      --no-auto-logout"
    print "                 Do not attempt to execute the exit or quit command at the end"
    print "                 of a script."
    print "      --no-prompt"
    print "                 Do not wait for a prompt anywhere. Note that this will also"
    print "                 cause Exscript to disable commands that require a prompt, such"
    print "                 as 'extract'."
    print "      --no-initial-prompt"
    print "                 Do not wait for a prompt after sending the password."
    print "      --no-strip"
    print "                 Do not strip the first line of each response."
    print "      --overwrite-logs"
    print "                 Instructs Exscript to overwrite existing logfiles. The default"
    print "                 is to append the output if a log already exists."
    print "  -p, --protocol STRING"
    print "                 Specify which protocol to use to connect to the remote host."
    print "                 STRING is one of: telnet ssh"
    print "                 The default protocol is telnet."
    print "      --retry NUM"
    print "                 Defines the number of retries per host on failure. Default"
    print "                 is 0."
    print "      --retry-login NUM"
    print "                 Defines the number of retries per host on login failure."
    print "                 Default is 0."
    print "      --sleep TIME"
    print "                 Waits for the specified time before running the script."
    print "                 TIME is a timespec as specified by the 'sleep' Unix command."
    print "      --ssh-auto-verify"
    print "                 Automatically confirms the 'Host key changed' SSH error "
    print "                 message with 'yes'. Highly insecure and not recommended."
    print "      --ssh-key FILE"
    print "                 Specify a key file that is passed to the SSH client."
    print "                 This is equivalent to using the -i parameter with ssh."
    print "  -v, --verbose NUM"
    print "                 Print out debug information about the network activity."
    print "                 NUM is a number between 0 (min) and 5 (max)"
    print "  -V, --parser-verbose NUM"
    print "                 Print out debug information about the Exscript parser."
    print "                 NUM is a number between 0 (min) and 5 (max)"
    print "      --version  Prints the version number."
    print "  -h, --help     Prints this help."

# Define default options.
default_options = [
  ('no-echo',           None, False),
  ('account-pool=',     None, None),
  ('connections=',      'c:', 1),
  ('csv-hosts=',        None, None),
  ('define=',           'd:', {}),
  ('delete-logs',       None, False),
  ('execute=',          'e:', None),
  ('hosts=',            None, None),
  ('default-domain=',   None, ''),
  ('non-interactive',   'i',  False),
  ('logdir=',           'l:', None),
  ('no-authentication', 'n',  False),
  ('no-prompt',         None, False),
  ('no-initial-prompt', None, False),
  ('no-auto-logout',    None, False),
  ('overwrite-logs',    None, False),
  ('verbose=',          'v:', 0),
  ('parser-verbose=',   'V:', 0),
  ('protocol=',         'p:', 'telnet'),
  ('retry=',            None, 0),
  ('retry-login=',      None, 0),
  ('sleep=',            None, ''),
  ('ssh-auto-verify',   None, False),
  ('ssh-key=',          None, None),
  ('no-strip',          None, False),
  ('version',           None, False),
  ('help',              'h',  False)
]

bracket_expression_re = re.compile(r'^\{([^\]]*)\}$')

def expand_bracket(value_name, value):
    match = bracket_expression_re.match(value)
    if match is None:
        return value
    prompt = match.group(1) or 'a value for "%s"' % value_name
    if prompt.startswith('!'):
        value = getpass.getpass('Please enter %s: ' % prompt[1:])
    else:
        value = raw_input('Please enter %s: ' % prompt)
    return value

def expand_host_variables(host):
    # Define host-specific variables.
    for key, val in host.vars.iteritems():
        try:
            val = val[0]
        except:
            val = None
        if not isinstance(val, str):
            continue
        val = expand_bracket(key, val)
        host.define(key, [val])

def run(*args, **kwargs):
    options = {}
    for option, short_option, value in default_options:
        option = re.sub(r'=$', '', option)
        options[option] = value
    options.update(kwargs)

    # Show the help, if requested.
    if options['help']:
        usage()
        sys.exit()

    # Show the version number, if requested.
    if options['version']:
        print "Exscript", __version__
        sys.exit()

    # Extract the hostnames out of the command line arguments.
    try:
        filename = args[0]
        hosts    = [Host(h) for h in list(args[1:])]
    except:
        usage()
        sys.exit(1)
    if options.get('execute') is not None:
        hosts.append(Host(filename))

    # If a filename containing hostnames AND VARIABLES was given, read it.
    if options.get('csv-hosts') is not None:
        try:
            csv_hosts = get_hosts_from_csv(options.get('csv-hosts'))
        except Exception, e:
            print e
            sys.exit(1)
        if not csv_hosts:
            print 'Warning: %s is empty.' % options.get('csv-hosts')
        hosts += csv_hosts

    # If a filename containing hostnames was given, read it.
    if options.get('hosts') is not None:
        try:
            txt_hosts = get_hosts_from_file(options.get('hosts'))
        except Exception, e:
            print e
            sys.exit(1)
        if not txt_hosts:
            print 'Warning: %s is empty.' % options.get('hosts')
        hosts += txt_hosts

    # Create the log directory.
    if options.get('logdir') is not None:
        if not os.path.exists(options.get('logdir')):
            print 'Creating log directory (%s)...' % options.get('logdir')
            try:
                os.makedirs(options.get('logdir'))
            except:
                print 'Error: Unable to create directory %s.' % options.get('logdir')
                sys.exit(1)

    # Make sure that all mandatory options are present.
    if not hosts:
        usage()
        sys.exit(1)

    # Read the Exscript.
    if options.get('execute') is not None:
        script_content = options.get('execute')
    else:
        file           = open(filename, 'r')
        script_content = file.read()
        file.close()

    # Prepare the code that is executed after the user script has completed.
    #FIXME: Move into the library, then use read_template_from_file instead of read_template().
    if not options['no-auto-logout']:
        script_content += r'''
    ## Exscript generated commands. ##
    {if device.guess_os() is "vrp"}
        {connection.send("quit\r", 0)}
    {else}
        {connection.send("exit\r", 0)}
    {end}'''

    # Test whether the template compiles.
    try:
        template.test(script_content, **options.get('define'))
    except Exception, e:
        if options['verbose'] > 0:
            raise
        print e
        sys.exit(1)

    # Create Exscript.
    protocol_args = {
        'echo':        not options.get('no-echo'),
        'auto_verify': not options.get('ssh-auto-verify')
    }
    exscript = Queue(domain         = options.get('default-domain'),
                     verbose        = options.get('verbose'),
                     max_threads    = options.get('connections'),
                     retries        = options.get('retry'),
                     login_retries  = options.get('retry-login'),
                     logdir         = options.get('logdir'),
                     overwrite_logs = options.get('overwrite-logs'),
                     delete_logs    = options.get('delete-logs'),
                     protocol_args  = protocol_args)
    account_manager = exscript.account_manager

    # Read the account pool file.
    try:
        if options['account-pool']:
            accounts = get_accounts_from_file(options['account-pool'])
            account_manager.add_account(accounts)
    except Exception, e:
        print e
        sys.exit(1)
    if options['account-pool'] and account_manager.n_accounts() == 0:
        msg = r'WARNING: No accounts found in account pool file (%s)!'
        print msg % options['account-pool']

    # Read username and password.
    try:
        if options['non-interactive'] or account_manager.n_accounts() > 0:
            user     = None
            password = None
        else:
            user, password = get_login()
    except:
        sys.exit(1)
    if user is not None:
        account = Account(user, password, ssh_key_file = options['ssh-key'])
        account_manager.add_account(account)

    # Ask for values of marked variables.
    for host in hosts:
        expand_host_variables(host)
    for key, val in options['define'].iteritems():
        options['define'][key] = expand_bracket(key, val)

    # Choose the template processing type.
    if options.get('no-prompt'):
        function = template.paste
    else:
        function = template.eval
    if not options.get('no-authentication'):
        nip      = options.get('no-initial-prompt')
        nop      = options.get('no-prompt')
        function = autologin(function, not nip and not nop)

    # Wait until the specified time.
    if options['sleep']:
        print "Waiting for %s..." % options['sleep'],
        sys.stdout.flush()
        os.system('sleep %s' % options['sleep'])
        print "time expired, starting script."

    # Run the template.
    tmpl_vars = options.get('define')
    if options.get('no-prompt'):
        exscript.run(hosts, function, script_content, **tmpl_vars)
    else:
        strip = not options.get('no-strip')
        exscript.run(hosts, function, script_content, strip, **tmpl_vars)

if __name__ == '__main__':
    # Parse options.
    try:
        options, args = OptionParser.parse_options(sys.argv, default_options)
    except:
        usage()
        sys.exit(1)

    run(*args, **options)
